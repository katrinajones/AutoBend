###Functions for bending analysis

#' Calculate mean bending data by joint for list of specimens
#'
#' @param ROM List of data frames
#' @param Joints Joints variable
#' @param Vars vector of variables names
#' @param order optional species order
#'
#' @return
#' @export
#'
#'
calc.means<-function(ROM, Joints, Vars){
  
  plotdat<-NULL
  for(i in 1:length(ROM)){
    
    if(nrow(ROM[[i]])==0){next}
    
    dat<-data.frame(Joint=ROM[[i]][,Joints], ROM[[i]][,Vars])
    avdat<-aggregate(dat, by=list(joint=dat$Joint), mean, na.rm=T)
    sd<-aggregate(dat, by=list(joint=dat$Joint), sd, na.rm=T)
    avdat<-colMeans(avdat, na.rm=T)
    sd<-colMeans(sd, na.rm=T)
    
    plotdati<-data.frame(species=rep(names(ROM)[i],length(Vars)), direction=as.factor(Vars), 
                         ROM=avdat[3:length(avdat)], sd=sd[3:length(avdat)])
    plotdat<-rbind(plotdat, plotdati)
    
  }
  

  
  return(plotdat)
}



#' Plot barplot of Range of motion data
#'
#' @param ROM List of ROM data for each specimen
#' @param Joints name of joints vector
#' @param Vars vector of variables to be included in the plot
#' @param order optional order vector for species
#' @param col.scale color for bars as scale_fill_manual values vector
#'
#' @return Barplot
#' @export
#'
#'
ROM.barplot<-function(ROM, Joints, Vars, order=NULL, col.scale, title, xlab="", ylab="", ylim){
  
 plotdat<-calc.means(ROM, Joints, Vars)
 #plotdat$species<-substr(plotdat$species,1,5)
 if(!is.null(order)){
   plotdat<-plotdat[which(plotdat$species%in%order),]
   plotdat$species<-factor(plotdat$species, levels=order)
 }
  
  p<- ggplot(plotdat, aes(x=species, y=ROM, fill=direction)) + 
    geom_bar(stat="identity", color="black", 
             position=position_dodge(), show.legend = F) +
    geom_errorbar(aes(ymin=ROM-sd, ymax=ROM+sd), width=.2,
                  position=position_dodge(.9)) +
    scale_fill_manual("legend", values = col.scale) + 
    theme_classic()+xlab(xlab)+ylab(ylab)+ 
    scale_y_continuous(limits=ylim)
  print(p)
  return(list(plot=p,dat=plotdat))

}


#' Make box plot for range of motion data
#'
#' @param ROM List of ROM data with each item as a species
#' @param Vars Variables to include
#' @param order Specimen order vector
#' @param col.scale color scale vector
#' @param title 
#'
#' @return
#' @export
#'
#'
ROM.boxplot<-function(ROM, Vars, order=NULL, col.scale, title){
  
  plotdat<-do.call(rbind.data.frame, ROM)
  n<-unlist(lapply(ROM, function(x) nrow(x)))
  Species<-rep(names(ROM), n)
  plotdat<-data.frame(Species=Species, plotdat[,Vars])  
  plotdat$Species<-substr(plotdat$Species,1,4)
  if(!is.null(order)){
    plotdat<-plotdat[which(plotdat$Species%in%order),]
    plotdat$Species<-factor(plotdat$Species, levels=order)
  }
  plotdat<-tidyr::gather(plotdat, key="direction", value="ROM", -"Species")
  
  
  p<- ggplot(plotdat, aes(x=Species, y=ROM, fill=direction)) + 
    geom_boxplot(position=position_dodge(1)) +
    scale_fill_manual("legend", values = col.scale) + 
    theme_classic()+ggtitle(title)
  print(p)
  
  
}

#' Load in silico bending data
#' 
#' Load data files into R generated by mayapy batch code
#'
#' @param dir.bending Directory where mayapy files are located 
#' @param dir.missing Directory where text files with same names containing information about missing joints are located
#'
#' @return List of bending data
#' @export
#'
#' 
load.insilico<-function(dir.bending, dir.missing){
  
  files<-list.files(dir.bending, pattern=".txt")
  ROM<-list()
  
  for(i in 1:length(files)){
    
    dat <- read.csv(file=paste0(dir.bending,"/", files[i]), header = T)
    char.cols<-!unlist(lapply(dat, is.numeric))
    dat[,char.cols]<-apply(dat[,char.cols], 2, gsub, pattern="\\[|\\]", replacement="")
    dat[,char.cols]<-apply(dat[,char.cols], 2, gsub, pattern="'", replacement="")
    dat[,char.cols]<-apply(dat[,char.cols], 2, gsub, pattern=" ", replacement="")
    dat<-as.data.frame(dat)
    colnames(dat)<-gsub("X.","",colnames(dat))

    #Check for missing joints
    miss <- read.csv(file=paste0(dir.missing,"/", gsub(".txt", ".csv",files[i])), header=T)
    if (any(miss$L==F)){
      miss2<-rep(miss$L,16)
      dat$TorR.[which(miss2==F)]<-NA
      dat$TorR_type.[which(miss2==F)]<-NA
      dat$LatR.[which(miss2==F)]<-NA
      dat$LatR_type.[which(miss2==F)]<-NA
    }
    if (any(miss$R==F)){
      miss2<-rep(miss$R,16)
      dat$TorL.[which(miss2==F)]<-NA
      dat$TorL_type.[which(miss2==F)]<-NA
      dat$LatL.[which(miss2==F)]<-NA
      dat$LatL_type.[which(miss2==F)]<-NA
    }
    if(any(miss$L==F & miss$R==F)){
      miss2<-dat$.joint.[which(miss$L==F & miss$R==F)]
      dat<-dat[!dat$.joint.%in%miss2,]#remove joint if both sides are bad
      region<-miss$Region[-which(miss$L==F & miss$R==F)]
    }else{region<-miss$Region}
    
    JointNo <- as.numeric(unlist(lapply(strsplit(dat$.joint., "_"), function(x) gsub("'", "",x[1]))))
    dat$TorR.<-abs(dat$TorR.)
    dat$LatR.<-abs(dat$LatR.)
    dat$VFL.<-abs(dat$VFL.)
    
    #Get region data
    n.repeats<-nrow(dat)/length(levels(as.factor(dat$.joint.)))
    region<-rep(region,n.repeats)
    
    #average left and right sides
    TorMean<-rowMeans(dat[,c("TorL.", "TorR.")], na.rm = T)
    LateroMean<-rowMeans(dat[,c("LatL.", "LatR.")], na.rm=T)
    Joint.name=factor(dat$.joint, levels=dat$.joint.[1:length(levels(as.factor(dat$.joint.)))])
    ROMi<-data.frame(Trial=as.factor(dat$Trial.), Species=rep(gsub(".txt","",files)[[i]],nrow(dat)), Joint.name=Joint.name,Joint=JointNo, 
                     Region=region, js=dat$joint.spacing.,
                     it=dat$intersection.threshold.,cent.strain=dat$cent.strain.,zyg.strain=dat$zyg.strain.,
                     Trans=dat$Translation., Trans.fact=dat$Transl.fact.,
                     Zyg.const=dat$Conditions.zyg., Cent.const=dat$Conditions.cent.,
                     Tor=TorMean*2, Latero=LateroMean*2, Dorso=dat$DFL., 
                     Ventro=dat$VFL., DV_ROM=(dat$DFL.+dat$VFL.), ratio_ROM=((dat$DFL.+dat$VFL.)/LateroMean),
                     dat[,c("TorL_type.","TorR_type.","LatL_type.","LatR_type.","DFL_type.","VFLtype..")])
    
    
    ROM[[i]]<-ROMi
    
  }
  names(ROM)<-gsub(".txt","",files)
  return(ROM)
}
  

#' Load morphological data
#' 
#' Load linear measurements for calculating stiffness
#'
#' @param dir.morph Directory containing csv files with same names as insilico
#'
#' @return morphological measurements
#' @export
#'
#' 
load.morphdata<-function(dir.morph, ROM){
  
  files.morph<-list.files(dir.morph, pattern=".csv")
  morph.all<-list()
  
  for(i in 1:length(files.morph)){
    
    dat <- read.csv(file=paste0(dir.morph,"/", files.morph[i]), header=T, na.strings = c("?", "    NA"))
    dat<- dat[,c("VERT","CL" , "Chpost" ,"Cwpost" ,"Chant" ,"Cwant", "ArchH")]
    
    #make joints
    anterior<-c( "CL"   , "Chpost"  ,  "Cwpost","ArchH" ,  "ArchW"  ,"InterZL", "Mid.LW" ,  "NSH"  ,   "NSL" ,  "totH"  ,  "totW"  ,"NSA"  , "TPL" ,"TPDV"   ,  "TPAP",   "size")# 
    anterior<-c(anterior[anterior%in%colnames(dat)])
    posterior<-c("CL"   ,  "Chant" ,   "Cwant" , "InterZL", "Mid.LW" ,  "PreZW" , "PreZA", "NSH"  , "NSL" ,  "totH"  ,  "totW"  , "NSA","ArchH"  )
    posterior<-c(posterior[posterior%in%colnames(dat)])
    morph<-create.joints(dat[,2:ncol(dat)],  anterior, posterior, dat$VERT)
    
    
    jointnos<-as.numeric(unlist(lapply(strsplit(as.character(morph$joint), "--"), function(x) x[[1]])))
    jointno<-as.factor(jointnos)
    
    #FIX MATCHING CODE WITH NEW NUMBERING SYSTEM AND CHECK
    #Match joints to ROM data
    #joint.match<-as.factor(jointnos-(jointnos[1]-1))
    
    morph<-data.frame(JOINT=jointno, morph)
    #Subset to used joints
    morph<-morph[morph$JOINT%in%levels(as.factor(ROM[[i]]$Joint)),]
    morph$JOINT<-droplevels(morph$JOINT)
    
    #size proxy
    meanCL<-mean(morph$CL, na.rm=T)
    morph<-data.frame(morph, meanCL)
    if(any(morph==0, na.rm=T)){morph[which(morph==0, arr.ind=TRUE)]<-NA}
    
    morph.all[[i]]<-morph
    
  }
  names(morph.all)<-gsub(".csv","",files.morph)
  return(morph.all)
  
}

#' Size correct morphological data
#'
#' @param morphdat List of sets of morphological data to correct
#' @param cols Columns that need to be corrected
#' @param measure Column name of measure to use for correction
#'
#' @return
#' @export
#'
#' 
sizecorrect.morph<-function(morphdat,cols, measure){
  
  morph.cat<-do.call(rbind.data.frame, morphdat)
  morph.cat<-removesize(morph.cat[,cols], size=morph.cat[,measure])
  sp<-as.factor(unlist(lapply(strsplit(rownames(morph.cat), split="[.]"), function(x) x[1])))
  morph.cat<-split(morph.cat, sp)
  for(i in 1:length(morphdat)){
    morphdat[[i]][,cols]<-morph.cat[[i]]
  }
  
  return(morphdat)
}


#' Calculate estimated stiffness
#' 
#' Calculate stiffness from ROM and dimensions of the centrum as log(Force*Lever arm/ROM).
#'
#' @param ROM List of ROM data
#' @param morphdat List of morphological data
#'
#' @return List of ROM and stiffness data
#' @export
#'
#' 
CalcStiffness<-function(ROM, morphdat){
  
  func<-list()
  
  for(i in 1:length(ROM)){
    
    dat<-morphdat[[names(ROM)[i]]]
    dat.ROM<-ROM[[i]]
    #dat<-rbind(dat,dat,dat,dat, dat, dat, dat, dat)
    if(any(dat.ROM==0, na.rm=T)){dat.ROM[which(dat.ROM==0, arr.ind = T)]<-NA}
    
    h<-rowMeans(cbind(dat$Chant,dat$Chpost))
    w<-rowMeans(cbind(dat$Cwant, dat$Cwpost))
    force<-(dat$Chant*dat$Cwant)^3/2
    #Use centrum dim, since total h/w often missing
    dorso.stiff<-log((force*((h/2)+dat$ArchH))/(dat.ROM$Dorso))#((h/2)+dat$ArchH)
    ventro.stiff<-log((force*(h/2))/(dat.ROM$Ventro))
    latero.stiff<-log((force*(w/2))/(dat.ROM$Latero))
    dv.stiff<-log((force*((h/2)+dat$ArchH))/dat.ROM$DV_ROM)
    
    func[[i]]<-data.frame(ROM[[i]], force=log(force),  DORSO=dorso.stiff, VENTRO=ventro.stiff, 
                          LATERO=latero.stiff, DV_Stiff=dv.stiff)
    
  }
  names(func)<-names(ROM)
  return(func)
}

#' Quantify constraints on motion
#' 
#' Examine distribution of stops on motion. How the stops are grouped are specified using the function terms.
#'
#' @param Funcdat Functional data from mayapy, list
#' @param splitby Variable used to split up the tables. use "species" if wish to split by species or NULL for none.
#' @param rows Variable used for the rows
#'
#' @return
#' @export Raw data as well as a formatted table and individual plots
#'
#' 
#' 
ConstonMotion<-function(Funcdat, splitby=c("Species"), rows=c("Joint")){
  
  #Reformat data
  inter<-do.call(rbind.data.frame, Funcdat)
  inter<-inter[,c("Species", "Region", "Joint.name", "Joint", "TorL_type.","TorR_type.","LatL_type.","LatR_type.","DFL_type.","VFLtype..")]
  colnames(inter)<-c("Species", "Region", "JOINT", "Joint","TorL", "TorR", "LatL", "LatR", "Dorso", "Ventro")

  #add together left and right bending
  Axial<-as.factor(c(as.character(inter$TorL), as.character(inter$TorR)))
  Latero<-as.factor(c(as.character(inter$LatL), as.character(inter$LatR)))
  rownames(inter)<-NULL
  inter<-data.frame(inter, Axial, Latero)
  
  #long version
  inter_long<-inter %>% pivot_longer(c(Dorso, Ventro, Latero, Axial), names_to="Direction", values_to="Stop")
  lev<-factor(c("intersect","cent_comp", "cent_ten", "jstrain" , "disart" , "none"), 
                 levels=c("intersect","cent_comp", "cent_ten", "jstrain" , "disart" , "none"))
  inter_long$Stop<-factor(trimws(gsub("\\'", "", inter_long$Stop)), levels=lev)
  inter_long$Stop<-revalue(inter_long$Stop, c("intersect"="Bony int.","cent_comp"="Centrum comp.",
                                              "cent_ten"="Centrum tension", "jstrain"="Zyg. comp." , 
                                              "disart"= "Zyg. tension", "none"="None"))

  #Make formula for creating tables
  f<-paste0("~ Direction + Stop +", rows)
  
  #if no split
  if(is.null(splitby)){
    
    #Table
    com.stops<-t(apply(xtabs(f, inter_long, drop.unused.levels = T), 
              3, function(y) apply(y,1, function(z) lev[which.max(z)])))
    com.stops<-data.frame(com.stops)
    
    #Bar chart
    const.plot<-list()
    stops<-xtabs(f, inter_long, drop.unused.levels = T)
    test<-group_by(data.frame(stops), Direction)
    test$Direction<-factor(test$Direction, c("Latero", "Axial" ,"Dorso","Ventro"))
    const.plot[[1]]<-local({
      p <- ggplot(test, aes(get(rows), Freq, fill=Stop))+
        geom_bar(stat = "identity", position="fill")+
        theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
              panel.background = element_rect(fill = NA),
              panel.grid.major = element_line(colour = NA),)+
        coord_flip()+ labs(title="All",x=rows) +
        scale_x_discrete(limits = rev(levels(test %>% pull(rows)))) +
        scale_fill_manual(values=brewer.pal(6, "Set2")) +
        facet_grid(cols=vars(Direction))
      print(p)
    })
  names(const.plot)<-c("all")
   
  }else{
  
  #Make table of most common stops
  inter_list<-split(inter_long, inter_long[,splitby])
  com.stops<-lapply(inter_list, function(x){
    t(apply(xtabs(f, x, drop.unused.levels = T), 
            3, function(y) apply(y,1, function(z) lev[which.max(z)])))
  })
  com.stops<-lapply(com.stops, data.frame)
  
  #Generate bar chart
  #Bar plot by frequency
  inter_list<-split(inter_long, inter_long[,splitby])
  stops<-lapply(inter_list, function(x){
    data=xtabs(f, x, drop.unused.levels = T)
  })
  
#Make bar plots
  const.plot<-list()
  for(i in 1:length(stops)){
  test<-group_by(data.frame(stops[[i]]), Direction)
  test$Direction<-factor(test$Direction, c("Latero", "Axial" ,"Dorso","Ventro"))

  const.plot[[i]]<-local({
  p <- ggplot(test, aes(get(rows), Freq, fill=Stop))+
    geom_bar(stat = "identity", position="fill")+
    theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
          panel.background = element_rect(fill = NA),
          panel.grid.major = element_line(colour = NA),)+
    
    coord_flip()+ labs(title=names(stops)[[i]],x=rows) +
    scale_x_discrete(limits = rev(levels(test %>% pull(rows)))) +
    scale_fill_manual(values=brewer.pal(6, "Set2")) +
    facet_grid(cols=vars(Direction))
  print(p)
  })
  }
  names(const.plot)<-names(stops)
  }
  
  return(list(Const=inter, comm_stops=com.stops, plots=const.plot))
 
}



#' Craniocaudal plot
#'
#' @param x Vertebral position
#' @param y Dependent variable
#' @param group grouping variable
#' @param vertline add vertical lines
#' @param linecols line colours
#' @param confcols confidence interval colours
#' @param legend 
#' @param ... 
#'
#' @return
#' @export
#'
#' 
craniocaudPlot<-function (x, y, group, vertline = NULL, linecols, confcols, legend = T, xlab="", ylab="",
                          conf.int=TRUE, title=NULL,
          ...) 
{
  group <- as.factor(group)
  x.fact <- x
  x <- as.numeric(x)
  plot.dat <- data.frame(x, y, group)
  plot.dat <- plot.dat[order(plot.dat$x), ]
  plot(plot.dat[, 1:2], type = "n", xaxt = "n", 
       xlab = xlab, ylab = ylab, ...)
  title(title, adj=0)
  abline(v = c(vertline), lty = 2, col = "grey")
  axis(1, c(1:max(x)), labels = levels(x.fact), las = 2, cex.axis = 0.5)
  for (i in c(1:nlevels(group))) {
    direct <- levels(group)[i]
    dat <- plot.dat %>% dplyr::filter(group == direct)
    dat <- dat[complete.cases(dat), ]
    B = splines::bs(dat$x, knots = seq(from = 1, to = max(dat$x), 
                                       by = 4), Boundary.knots = c(1, max(dat$x)), degre = 3)
    reg = lm(dat$y ~ B)
    P = predict(reg, interval = "confidence")
    if(isTRUE(conf.int)){
    polygon(c(dat$x, rev(dat$x)), c(P[, 2], rev(P[, 3])), 
            col = confcols[i], border = NA)
    }
    lines(dat$x, predict(reg), col = linecols[i])
  }
  if (isTRUE(legend)) {
    legend(min(plot.dat$x), max(plot.dat$y, na.rm = T), levels(plot.dat$group), 
           fill = confcols, bty = "n", cex = 0.8)
  }
  points(plot.dat[, 1:2], col = confcols[plot.dat$group], pch = as.numeric(plot.dat$group))
}


#' Compile craniocaudal and barplots
#' 
#' Make bending plots with insilico craniocaudal and barplots
#'
#' @param plotdata 
#'
#' @return
#' @export
#'
#' 
compile.plots<-function(plotdat, linecols, confcols, ylim_cc, ylim_bar, pagedim, 
                        mar, conf.int=TRUE, title, FctOrder){
  
  nplots<-length(plotdat)
  ylab_cc<-c(rep("ROM (Degrees)",2),rep("oROM (Degrees)",nplots-2))
  dev.new(width=pagedim[1], height=pagedim[2])
  par(mar=mar)
  ROMplots<-list()
  
  #craniocaudal plots
  
  for(i in 1:length(plotdat)){
    
    plotdata<-plotdat[[i]]
    plotdata$JOINT.name<-droplevels(plotdata$JOINT.name)
    plotdata<-tidyr::gather(plotdata,"Direction","ROM", "Latero", "Sag", "Tor")
    plotdata$Direction<-revalue(plotdata$Direction, c('Sag'="1Sag", "Latero"="2Latero", "Tor"="3Torson"))
    plotdata$Direction<-as.factor(plotdata$Direction)
    craniocaudPlot(x=plotdata$JOINT.name,y=plotdata$ROM,group=plotdata$Direction, 
                   linecols = linecols, confcols = confcols, legend=F, xlab="Joint", ylab=ylab_cc[i],
                   ylim=ylim_cc, conf.int=conf.int[i], title=title[i])
    grid.echo()
    ROMplots[[i]]<-grid.grab()
    
  }
  
  #Barplots
  ylab_bar<-c(rep("ROM (Degrees)",2),rep("oROM (Degrees)",(nplots-2)))
  barplots<-list()
  #ROM
  for(i in seq(1,nplots, by=2)){
    Joints<-"JOINT"
    Vars<-c("Sag", "Latero", "Tor")
    col.scale<-c("Sag"=linecols[1], "Latero"=linecols[2], "Tor"=linecols[3])
    
    valbar<-do.call(rbind.data.frame, list(plotdat[[i]], plotdat[[i+1]]))
    valbar<-split(valbar, valbar$Species)
    barplots[[i]]<-print(ROM.barplot(valbar, Joints, Vars,order=c("Cat", "Tegu"), col.scale, 
                               ylab=ylab_bar[i],ylim=ylim_bar)$plot)
  }
  
 #lineplots

  plotdat2 = ROM.dplyrProcess(ROM=plotdat,Joint="JOINT",
                             grpvars = c("df_label","Trial", "Species"),
                             dirvars = c("Latero", "Sag", "Tor"),
                             FctOrder = FctOrder)
  
  dotplot<-ROM.ggPointsFilledLines(plotdat2,
               col.scale=c("tomato","slategrey","gold"),
               title=title,xlab="",ylab="Mean ROM (Degrees)",ylim=ylim_bar)
  
  #dotplot<-ROM.ggPointsLines(pltdf=plotdat2,BaselineVars = c("Trial", levels(plotdat2$Trial)[1]),
   #                 col.scale=c("tomato","slategrey","gold"),
    #                title=title,xlab="",ylab=ylab_bar[1],ylim=ylim_bar)
  
  
  
  
  
   return(list(CCplot=ROMplots, Bar=barplots, dot=dotplot))
  
  
}
